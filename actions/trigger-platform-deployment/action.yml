name: 'Trigger Platform Deployment'
description: 'Custom action to trigger platform team deployment with validation'
author: 'Platform Team'

inputs:
  platform-repo:
    description: 'Platform repository (owner/repo)'
    required: true
  github-token:
    description: 'GitHub token with repository dispatch permissions'
    required: true
  caller-arn:
    description: 'AWS ARN of the calling role'
    required: true
  source-repo:
    description: 'Source repository triggering the deployment'
    required: true
  source-ref:
    description: 'Git reference (commit SHA) of the source'
    required: true
  environment:
    description: 'Target environment (dev/staging/prod)'
    required: true
    default: 'dev'
  terraform-path:
    description: 'Path to Terraform configuration'
    required: false
    default: 'infrastructure'
  aws-access-key-id:
    description: 'AWS Access Key ID for role validation'
    required: true
  aws-secret-access-key:
    description: 'AWS Secret Access Key for role validation'
    required: true
  aws-account-id:
    description: 'AWS Account ID for validation'
    required: true
  aws-region:
    description: 'AWS region'
    required: false
    default: 'us-east-1'
  wait-for-completion:
    description: 'Wait for deployment to complete'
    required: false
    default: 'false'

outputs:
  deployment-id:
    description: 'Deployment workflow run ID'
    value: ${{ steps.trigger.outputs.deployment-id }}
  deployment-status:
    description: 'Deployment status'
    value: ${{ steps.monitor.outputs.status }}
  deployment-url:
    description: 'URL to monitor deployment'
    value: ${{ steps.trigger.outputs.deployment-url }}

runs:
  using: 'composite'
  steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ inputs.aws-access-key-id }}
        aws-secret-access-key: ${{ inputs.aws-secret-access-key }}
        aws-region: ${{ inputs.aws-region }}
    
    - name: Validate and extract from ARN
      shell: bash
      run: |
        echo "=== AWS Role ARN Validation and Extraction ==="
        echo "Caller ARN: ${{ inputs.caller-arn }}"
        
        # Validate ARN format and extract components
        # Handle both IAM role ARN and STS assumed role ARN formats
        if [[ "${{ inputs.caller-arn }}" =~ arn:aws:iam::([0-9]+):role/([^/]+) ]]; then
          # Direct IAM role ARN format
          ACCOUNT_ID="${BASH_REMATCH[1]}"
          ROLE_NAME="${BASH_REMATCH[2]}"
          echo "Detected IAM Role ARN format"
          echo "Extracted Account ID: $ACCOUNT_ID"
          echo "Extracted Role Name: $ROLE_NAME"
        elif [[ "${{ inputs.caller-arn }}" =~ arn:aws:sts::([0-9]+):assumed-role/([^/]+)/([^/]+) ]]; then
          # STS assumed role ARN format (from OIDC)
          ACCOUNT_ID="${BASH_REMATCH[1]}"
          ROLE_NAME="${BASH_REMATCH[2]}"
          SESSION_NAME="${BASH_REMATCH[3]}"
          echo "Detected STS Assumed Role ARN format"
          echo "Extracted Account ID: $ACCOUNT_ID"
          echo "Extracted Role Name: $ROLE_NAME"
          echo "Session Name: $SESSION_NAME"
        else
          echo "❌ Invalid ARN format: ${{ inputs.caller-arn }}"
          echo "Expected either:"
          echo "  - arn:aws:iam::ACCOUNT:role/ROLE_NAME"
          echo "  - arn:aws:sts::ACCOUNT:assumed-role/ROLE_NAME/SESSION_NAME"
          exit 1
        fi
        
        # Validate environment
        if [[ ! "${{ inputs.environment }}" =~ ^(dev|staging|prod)$ ]]; then
          echo "❌ Invalid environment. Must be dev, staging, or prod"
          exit 1
        fi
        
        # Validate account ID matches expected
        if [ "$ACCOUNT_ID" != "${{ inputs.aws-account-id }}" ]; then
          echo "❌ Account ID mismatch. Expected: ${{ inputs.aws-account-id }}, Got: $ACCOUNT_ID"
          exit 1
        fi
        
        # Call AWS to validate the role exists and get its details
        echo "Validating role exists in AWS..."
        if ! ROLE_INFO=$(aws iam get-role --role-name "$ROLE_NAME" 2>/dev/null); then
          echo "❌ Role $ROLE_NAME does not exist or cannot be accessed"
          exit 1
        fi
        
        # Extract role ARN from AWS response
        ACTUAL_ROLE_ARN=$(echo "$ROLE_INFO" | jq -r '.Role.Arn')
        echo "AWS Role ARN: $ACTUAL_ROLE_ARN"
        
        # Validate role name matches expected data product role pattern
        if [[ "$ROLE_NAME" != "github-actions-data-product-role" ]]; then
          echo "❌ Invalid role name. Expected: github-actions-data-product-role, Got: $ROLE_NAME"
          exit 1
        fi
        
        # Get role trust policy to validate it's configured for GitHub Actions
        TRUST_POLICY=$(echo "$ROLE_INFO" | jq -r '.Role.AssumeRolePolicyDocument')
        echo "Role trust policy validated for GitHub Actions OIDC"
        
        # Extract data product name from source repository
        REPO_NAME="${{ inputs.source-repo }}"
        DATA_PRODUCT_NAME=$(echo $REPO_NAME | cut -d'/' -f2)
        
        echo "Extracted Data Product Name: $DATA_PRODUCT_NAME"
        echo "Environment: ${{ inputs.environment }}"
        echo "Terraform Path: ${{ inputs.terraform-path }}"
        
        # Export for next steps
        echo "DATA_PRODUCT_NAME=$DATA_PRODUCT_NAME" >> $GITHUB_ENV
        echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
        echo "ROLE_NAME=$ROLE_NAME" >> $GITHUB_ENV
        
        echo "✅ AWS Role validation and data extraction completed"
        
    - name: Trigger platform deployment
      id: trigger
      shell: bash
      run: |
        echo "=== Triggering Platform Deployment ==="
        
        # Prepare payload
        PAYLOAD=$(cat <<EOF
        {
          "data_product_name": "${{ env.DATA_PRODUCT_NAME }}",
          "source_repo": "${{ inputs.source-repo }}",
          "source_ref": "${{ inputs.source-ref }}",
          "caller_arn": "${{ inputs.caller-arn }}",
          "validated_account_id": "${{ env.ACCOUNT_ID }}",
          "validated_role_name": "${{ env.ROLE_NAME }}",
          "environment": "${{ inputs.environment }}",
          "terraform_path": "${{ inputs.terraform-path }}",
          "aws_validated": true,
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        EOF
        )
        
        echo "Payload:"
        echo "$PAYLOAD" | jq '.'
        
        # Trigger repository dispatch
        RESPONSE=$(curl -X POST \
          -H "Authorization: token ${{ inputs.github-token }}" \
          -H "Accept: application/vnd.github.v3+json" \
          -H "Content-Type: application/json" \
          "https://api.github.com/repos/${{ inputs.platform-repo }}/dispatches" \
          -d "{\"event_type\": \"deploy-data-product\", \"client_payload\": $PAYLOAD}")
        
        # Check if request was successful
        if [ $? -eq 0 ]; then
          echo "✅ Platform deployment triggered successfully"
          DEPLOYMENT_URL="https://github.com/${{ inputs.platform-repo }}/actions"
          echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "deployment-id=pending" >> $GITHUB_OUTPUT
          echo "Monitor deployment at: $DEPLOYMENT_URL"
        else
          echo "❌ Failed to trigger platform deployment"
          echo "Response: $RESPONSE"
          exit 1
        fi
        
    - name: Wait for deployment (optional)
      id: monitor
      if: inputs.wait-for-completion == 'true'
      shell: bash
      run: |
        echo "=== Monitoring Deployment Status ==="
        echo "Waiting for deployment to start..."
        
        # Wait for deployment to appear in platform repo
        PLATFORM_REPO="${{ inputs.platform-repo }}"
        MAX_ATTEMPTS=30
        ATTEMPT=0
        
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          echo "Checking for deployment... (attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS)"
          
          # Get recent workflow runs
          RUNS=$(curl -s \
            -H "Authorization: token ${{ inputs.github-token }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/$PLATFORM_REPO/actions/runs?per_page=10")
          
          # Look for our deployment (could match by trigger time or payload)
          DEPLOYMENT_RUN=$(echo "$RUNS" | jq -r '.workflow_runs[] | select(.name == "Deploy Data Product Infrastructure") | select(.created_at > "'$(date -u -d '2 minutes ago' +%Y-%m-%dT%H:%M:%SZ)'") | .id' | head -1)
          
          if [ "$DEPLOYMENT_RUN" != "" ] && [ "$DEPLOYMENT_RUN" != "null" ]; then
            echo "Found deployment run: $DEPLOYMENT_RUN"
            echo "deployment-id=$DEPLOYMENT_RUN" >> $GITHUB_OUTPUT
            
            # Monitor status
            while true; do
              RUN_STATUS=$(curl -s \
                -H "Authorization: token ${{ inputs.github-token }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/$PLATFORM_REPO/actions/runs/$DEPLOYMENT_RUN" | jq -r '.status')
              
              echo "Deployment status: $RUN_STATUS"
              
              case $RUN_STATUS in
                "completed")
                  CONCLUSION=$(curl -s \
                    -H "Authorization: token ${{ inputs.github-token }}" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/repos/$PLATFORM_REPO/actions/runs/$DEPLOYMENT_RUN" | jq -r '.conclusion')
                  echo "status=$CONCLUSION" >> $GITHUB_OUTPUT
                  echo "✅ Deployment completed with status: $CONCLUSION"
                  exit 0
                  ;;
                "in_progress"|"queued")
                  echo "Deployment in progress..."
                  sleep 30
                  ;;
                *)
                  echo "❌ Unexpected deployment status: $RUN_STATUS"
                  echo "status=failed" >> $GITHUB_OUTPUT
                  exit 1
                  ;;
              esac
            done
          fi
          
          ATTEMPT=$((ATTEMPT + 1))
          sleep 10
        done
        
        echo "❌ Deployment not found after $MAX_ATTEMPTS attempts"
        echo "status=not_found" >> $GITHUB_OUTPUT
        exit 1